<!DOCTYPE html>
<html>
<head>
<title>03_코딩테스트_디자인패턴편_v1.0.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>
<link rel="stylesheet" href="file:///c%3A/Users/PaperKim/Desktop/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8_%EA%B0%95%EC%9D%98%EC%9E%90%EB%A3%8C/custom/github2.css" type="text/css"><link rel="stylesheet" href="file:///c%3A/Users/PaperKim/Desktop/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8_%EA%B0%95%EC%9D%98%EC%9E%90%EB%A3%8C/custom/darcula.css" type="text/css"><link rel="stylesheet" href="file:///c%3A/Users/PaperKim/Desktop/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8_%EA%B0%95%EC%9D%98%EC%9E%90%EB%A3%8C/custom/custom.css" type="text/css">
<style>
/*

Darcula color scheme from the JetBrains family of IDEs

*/


.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #2b2b2b;
  color: #bababa;
}

.hljs-strong,
.hljs-emphasis {
  color: #a8a8a2;
}

.hljs-bullet,
.hljs-quote,
.hljs-link,
.hljs-number,
.hljs-regexp,
.hljs-literal {
  color: #6896ba;
}

.hljs-code,
.hljs-selector-class {
  color: #a6e22e;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-section,
.hljs-attribute,
.hljs-name,
.hljs-variable {
  color: #cb7832;
}

.hljs-params {
  color: #b9b9b9;
}

.hljs-string {
  color: #6a8759;
}

.hljs-subst,
.hljs-type,
.hljs-built_in,
.hljs-builtin-name,
.hljs-symbol,
.hljs-selector-id,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-template-tag,
.hljs-template-variable,
.hljs-addition {
  color: #e0c46c;
}

.hljs-comment,
.hljs-deletion,
.hljs-meta {
  color: #7f7f7f;
}

</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
/* Change the old color so it seems less like an error */
/* :not(pre):not(.hljs) > code {
	color: #C9AE75;
	font-size: inherit;
} */

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
<link rel="stylesheet" href="file:///c%3A/Users/PaperKim/Desktop/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8_%EA%B0%95%EC%9D%98%EC%9E%90%EB%A3%8C/custom/github2.css" type="text/css"><link rel="stylesheet" href="file:///c%3A/Users/PaperKim/Desktop/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8_%EA%B0%95%EC%9D%98%EC%9E%90%EB%A3%8C/custom/darcula.css" type="text/css"><link rel="stylesheet" href="file:///c%3A/Users/PaperKim/Desktop/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8_%EA%B0%95%EC%9D%98%EC%9E%90%EB%A3%8C/custom/custom.css" type="text/css">
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="gofgang-of-four-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-design-patterns-elements-of-reusable-object-oriented-software">GoF(Gang of Four) 디자인 패턴 (Design Patterns: Elements of Reusable Object-Oriented Software)</h1>
<h2 id="%EC%A0%80%EC%9E%90-%EB%B0%8F-%EC%B6%9C%EA%B0%84">저자 및 출간</h2>
<ol>
<li>
<p>출간 일자 : 1994년</p>
</li>
<li>
<p>저자</p>
<ul>
<li>Erich Gamma</li>
<li>Richard Helm</li>
<li>Ralph Johnson</li>
<li>John Vlissides</li>
</ul>
</li>
</ol>
<h2 id="chatgpt%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-%EA%B3%B5%EB%B6%80-%EB%B0%A9%EB%B2%95">ChatGPT를 활용한 디자인 패턴 공부 방법</h2>
<ol>
<li>
<p>검색어</p>
<pre><code class="code-line language-"><div>XXX 패턴에 대해서 설명해.
- 정의
- 장점과 단점
- 단점 보완 패턴 나열 및 단점 보완의 기준
- PlantUML 기반 정의적 UML 표기
</div></code></pre>
<p>위와 같이 입력해서 확인해볼 수 있다.</p>
</li>
<li>
<p>디자인 패턴에서 익여햐할 항목들</p>
<ul>
<li>정의 : 특정 디자인 패턴에 대해서 정의하고 이해해야 한다.</li>
<li>코드 : 특정 언어에서 구현된 현상을 익힌다.</li>
<li>적용 : 이부분은 직접 경험해보지 않고서는 불가능하다. 타인이 구현한 정황들을 많이 느껴봐야한다.</li>
</ul>
</li>
</ol>
<h2 id="%EC%83%9D%EC%84%B1-%EC%83%9D%EC%84%B1-%ED%8C%A8%ED%84%B4creational-patterns">생성 생성 패턴(Creational Patterns)</h2>
<ol>
<li>
<p>생성 패턴</p>
<blockquote>
<br>
생성 패턴 : 객체 생성 과정에 관련되는 패턴이다.<br>
<br>
<ul>
<li>유연성 : 생성 과정을 유연하게 하여 유지보수성 및 확장성을 높인다.</li>
<li>인스턴스화 매커니즘 정의 : 인스턴스화 과정을 캡슐화하여 객체가 잘 생성될 수 있도록 하거나 시스템이 특정 클래스의 인스턴스화로부터 독립시킨다. 또한, 생성 과정을 외부 또는 서브 클래스에 위임하여 과정 자체를 숨기고 단순화 한다.</li>
</ul>
<br>
</blockquote>
</li>
<li>
<p>단일체(Singleton)</p>
<blockquote>
<br>
싱글톤 : 단일 객체만 생성한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>메모리 효율성 : 한 개 객체만 유지한다. → 인스턴스 수 감소</li>
<li>전역성 : 어디서든지 접근 가능하다. → 쉬운 접근성</li>
<li>공유성 : 다른 클래스 객체들 사이에서 공유 상태 유지한다. → 공유화</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>추적성 문제 : 다른 클래스 객체들 사이에서 의존성 강화한다. → 코드 변경 및 테스트 어려움</li>
<li>동시성 문제 : 멀티 스레딩 환경에서 동시 접근이 가능하다. → 동기화 등과 같은 동시성 관리 어려움</li>
<li>OOP 설계 원칙 위배 문제 : 싱글톤 객체 자체가 너무 많은 역할을 담당할 수 있다. → 객체 지향 설계 원칙 위배</li>
<li>역할 문제 : 접근이 쉽다. → 과도한 역할 담당할 가능성</li>
</ul>
</li>
<li>
<p>단점 보완 패턴 및 기준</p>
<ul>
<li>서비스 로케이터 패턴(Service Locator Pattern) : 의존성 객체를 직접 싱글톤 객체 생성없이, 중앙 집중식 위치에서 서비스를 찾을 수 있게 한다. → 전역 상태 관리에 대한 복잡도 감소, 의존성 주입 용이</li>
<li>의존성 주입 패턴(Dependency Injection Pattern) : 의존성 객체를 외부에서 주입한다. → 전역 상태 관리 문제 완화, 유연한 의존성 관리, 테스트와 유지보수성 증가</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/SoWkIImgAStDuU9I08BadCJYOeNWpBpqdDII_3o5Qh0e2EW25PPa9YjavW4PUScfLWXL23Lm8GrDkA0sL6DwQeadLA-69f9k1Li53PYXG3QSgMYhu1VgusEF4B5Io4ijHsY4M56Bx73ddCpKl18aLsid5wKcbc1O26VheRWAsK2eKNef-ULvUdP8kgqKIejJYo6A4AAwfGMwIAgi520MGzNbvPUaAkIaffKevASXARB25bvlPkvulQr1uMtZbjVpPhpfMl9cxWo5DtDt05blMxQ0o9bJ55vlMFbcUGDOIsfU2jXuBYu781COaG00" alt="uml diagram">
</li>
<li>
<p>원형 복제(Prototype)</p>
<blockquote>
<br>
프로토타입 : 기본 객체를 복제하여 생성한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>생성 과정 단순화 : 복잡한 객체 생성 과정을 단순화 시킨다. → 생성 비용 절감</li>
<li>런타임 관리성 : 실행 중에 새 객체를 동적으로 생성/삭제 가능하다. → 무중단</li>
<li>메모리 효율성 : 클래스에서 파생된 객체의 수를 감소시킨다. → 파생 감소</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>복제 기술 문제 : 깊은 복사(Deep Copy)와 얕은 복사(Shallow Copy)에 대한 이해를 요구한다. → 기술적 이해 필요</li>
<li>복잡도 문제 : 복잡한 객체 그래프라면, 그래프의 모든 객체가 올바르게 복제되어야한다. → 과정 복잡도 증가</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>추상 팩토리 패턴(Abstract Factory Pattern) : 객체의 생성을 위한 인터페이스를 제공한다. → 복잡한 초기화 문제 간소화</li>
<li>빌더 패턴(Builder Pattern) : 복잡한 객체를 단계별 구축 환경을 제공한다. → 복잡한 복제/생성 과정 단순화, 유지보수성 증가</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/ZP1D2i8m48NtESKiMyGSeA0Kl81N276qWVmnCrsKujsDjTg0BfpjuttVOteMGp86hnIKSr6GhiOYd2b9aYaZp4lol9trAMBJTbkwPFTNsNh33ASKBQ7W1d0XUmmOXV-bmW5aSAnjobFJ_d1uLt0LOv_VrNfRfI0qykNubFGweJQj3atkDeW-LiKEHaPMgiTuAPzx0000" alt="uml diagram">
</li>
<li>
<p>공장(Factory Method)</p>
<blockquote>
<br>
팩토리 메소드 : 객체 생성을 추상화하여 객체 생성은 구현 클래스에 위임한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>분할성 : 객체 생성에 대해 인터페이스를 정의하고, 객체 생성은 구현 클래스에서 결정 및 생성한다. → 생성 추상화</li>
<li>느슨한 결합 : 객체 생성 코드와 클라이언트 코드를 분리 및 캡슐화한다. → 생성 의존성 분리, 코드의 유연성, 재사용성 증가</li>
<li>확장성 : 추가 클래스 공급 시 기존 코드에 대한 변경없이 새 팩토리 코드 클래스만 추가하면 된다. → 쉬운 확장</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>복잡도 문제 : 단순 생성 과정일 경우 추가적 인터페이스/클래스가 필요해진다. → 복잡도 증가</li>
<li>계층화 문제 : 클라이언트 코드와 팩토리 메소드 간 많은 수의 중간 계층이 만들어질 수 있다. → 복잡도 증가</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>추상 팩토리 패턴(Abstract Factory Pattern) : 제품(객체)에 제품군(객체 집합)을 부여한다. → 추가적 복잡도 증가없이 제품군 추가</li>
<li>빌더 패턴(Builder Pattern) : 객체의 구성을 단계별로 분리하여 생성 과정을 단순화한다. → 복잡도 감소, 유지보수성 증가</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/hLBB2eCm4Bpx5NjKYdw0KD4KUYlq5q9Sgw2n92kbIF-zLkEpbbhe7X9OTcPs9WarSKLLaLlGL7jaab0bN20SkQ1ItQ5k-w_Q9LthX9IMiUtuS5PbN0bg9nvMUucSQms7KWg5X8OaWgouvbYW9FqBCUn1ucrWCzt8ThugihygihdY65AFgZylr2yzNMWxZ6s5vLapCd7e6eT-xtxqtl1pmhbfC-qjSfaA6GbNPPUKt618rOTAepOpotVtlE0z2H-w5VGQXgrXs0HZXIZZvjC-0G00" alt="uml diagram">
</li>
<li>
<p>추상 공장(Abstract Factory)</p>
<blockquote>
<br>
앱스트랙트 팩토리 : 제품군(객체 집합) 생성에 대해 인터페이스를 제공하고, 객체 생성은 팩토리 메소드 패턴 유형 클래스에서 생성한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>느슨한 결합 : 팩토리 메소드 패턴의 팩토리 구현 클래스를 추상화한다. → 생성 의존성 분리, 코드의 유연성, 재사용성 증가</li>
<li>단순화 : 일관된 방식으로 객체 집합을 생성한다. → 복잡도 감소</li>
<li>호환성 : 함께 사용되는 객체들을 생성한다. → 호환성 증가</li>
<li>유지보수성 : 제품군을 쉽게 교체하거나 업데이트 가능하다. → 유지보수성 증가</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>확장성 문제 : 새 종류의 제품 제공을 위해서는 팩토리 인터페이스에 맞는 새로운 팩토리를 생성해야한다. → 확장성 감소</li>
<li>복잡도 문제 : 많은 인터페이스와 클래스가 필요해진다. → 복잡도 증가</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>팩토리 메소드 패턴(Factory Method Pattern) : 개별 객체 생성을 수행한다. → 추상 팩토리의 다수 책임성 분할</li>
<li>프로토타입 패턴(Prototype Pattern) : 객체 복제를 통해 단순하게 생성한다. → 객체 종류 관리에 대한 복잡도 감소, 유연성 증가</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/jPHDQiCm48NtFiKi4ueDqTBGa4oWwrv1LIQjmPQBDAQ4qBjNZN-m7CM96chmmjRtPjxeoTvObeQRgamIS5UXcSn1AeBjcsKZ5R-ukpP7E9tNVwydPKWolPfwtoZUBfRv0FVlhh0OOF7CVbzhtrVi-j_YqETKAQs5NQsT3QPkb1KKrMT95McsZuq9pw3f2_h7rM8PCxYlnbuzPrtybtNna7KHiZxiIiXpE5PVAFuenBcEE2SKiS9TMJXsjFFfeGqZdwOJcKrN9fl2aI45ow2VLZT3Qeht3qxN5ySgXyQIRTdfMZhY1_SvjEtilHASI2w-ronRZuxJ_J3UW8LNMKJ0E8QJ3Ucz-uN-0000" alt="uml diagram">
</li>
<li>
<p>건설자(Builder)</p>
<blockquote>
<br>
빌더 : 생성 각 과정을 함수로 단계화 시키고, 각 단계의 조합으로 객체를 생성한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>유연성 : 같은 생성 절차에서 서로 다른 상태를 기반으로 생성할 수 있게 한다. → 다양성 증가</li>
<li>가독성 : 생성 과정의 클라이언트 코드로부터 분리한다. → 생성 과정 가독성 증가</li>
<li>생성 절차 : 동일한 생성 절차에서 생성 과정을 제어하여 다양한 상태의 객체로 만들어낼 수 있다. → 생성 복잡도 감소 및 상태 관리 용이</li>
<li>캡슐화 : 빌더 인터페이스를 통해 구체적 객체 생성 과정 정보없이도 객체를 쉽게 생성한다. → 사용성 증가</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>복잡도 문제 : 생성 과정의 단계가 오히려 어려워지거나 생성에 대한 코드가 많아질 수도 있다. → 생성 복잡도 증가</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>팩토리 메소드 패턴(Factory Method Pattern): 세분화된 생성 과정을 단일 단계로 객체를 생성한다. → 생성 복잡도 감소</li>
<li>프로토타입 패턴(Prototype Pattern): 생성 대상 객체의 구성이 결정된 빌더를 복제하여 쉽게 생성한다. → 생성 복잡도 감소</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/VLDRRiCW4FptALR-IjJQ1x3KAe4BHEe977kR8c6m02SVLUzUderjGVb1tfbPPWTyqgPNPfbuLO5TJ1XKd_s0G1R6HrJmxUjklSoMUJuSkuHj4L94Q1Qvke93BagEos0yyXDi3BpN6gWKWqA3oGgRPeuJ2gCpxfevj5dtArk7DuZyraFskpxNvO5sVEBuf2wFkUDJnwTrUVWd7wG2WOy47BozL_2dXeqUCr5nPdDPnt4DHjR1Fu-tiVO6BocKksIZTH0bRGohZIPpCbAGaVzbj22ZEzbcjXJH-gwTmmu-Z6BYjYsJV9bkoh5_JArHxFPbclU_o-jWqQW39zMQKJw4vIGt7OInTEYqUwgjRzdcwDK9nMX_k5y0" alt="uml diagram">
</li>
</ol>
<h2 id="%EA%B5%AC%EC%A1%B0-%ED%8C%A8%ED%84%B4structural-patterns">구조 패턴(Structural Patterns)</h2>
<ol>
<li>
<p>구조 패턴</p>
<blockquote>
<br>
구조 패턴 : 클래스 또는 객체를 조합해 더 큰 구조를 구축할 수 있도록 설계와 관련되는 패턴이다.<br>
<br>
<ul>
<li>효율성 : 동작 자체에서 불필요한 부분을 제거해 단순화 하거나 관계 강화를 통해 유지보수성을 높인다.</li>
<li>독립성 : 고수준의 추상화를 제공하여 객체 간 결합도를 감소시킨다.</li>
<li>확장성 : 기존 코드 변경없이 새로운 기능을 쉽게 추가할 수 있도록 한다.</li>
</ul>
<br>
</blockquote>
</li>
<li>
<p>변환자(Adapter)</p>
<blockquote>
<br>
어댑터 : 인터페이스 호환성 문제가 있는 객체 사이에서 중개한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>호환성 : 기존 코드를 변경하지 않고도 새 인터페이스와 호환 가능하고, 서로 다른 객체끼리 연결시키는 것 또한 가능하다. → 호환성 증가</li>
<li>느슨한 결합 : 기존 코드와 클라이언트 코드 사이에서 직접 변환을 수행한다. → 의존성 분리, 코드의 유연성</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>복잡도 문제 : 어댑터 코드를 작성해야 한다.  → 복잡도 증가</li>
<li>성능 문제 : 어댑터 객체가 추가된다.  →  성능 저하</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>퍼사드 패턴(Facade Pattern): 다수 인터페이스에 대해 변환 시 단일 인터페이스를 제공한다. → 복잡도 감소</li>
<li>데코레이터 패턴(Decorator Pattern): 기능 전환에 대해 동적으로 책임을 추가/제거한다. → 런타임 유연성 증가 및 복잡도 관리에 대해 확장성 증가</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/TP513e8m44NtdcAM6WC78D5Wl84tQ3g3Jb8GEuCRuzqj591OxAABzl__vhUbgF7QrMwpWR2iCo9mGjCg4Ro6itxjfINB5TiBFJeItUuAUDuP1y4xUhbHyfMnDFfnwVUhldvFk1wuRXtLrAYiH6KcJbTCOyutVsbmWD6K9psM3U8KPyS1dH9n8k8Nr0ab4CpzMlWOctc-tZGxpiqA225HClN_qL3G3D4I7woa1iEFVG00" alt="uml diagram">
</li>
<li>
<p>다리(Bridge)</p>
<blockquote>
<br>
브릿지 : 추상 수준(인터페이스)과 구현 수준(구현 클래스)을 분리하여, 독립적으로 변형할 수 있도록 한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>느슨한 결합 : 추상화와 구현을 분리한다. → 의존성 분리, 응집도 증가, 결합도 감소, 유연성 증가</li>
<li>유지보수성 : 구현 변경이 추상화에 영향을 주지 않는다. → 유지보수 용이성 및 확장성 증가</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>복잡도 문제 : 디자인이 복잡해진다. → 추적성 및 이해도 저하</li>
<li>설계 문제 : 적절한 추상화 계층 설계가 중요하다. → 유연성 저하 가능성</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>스트레티지 패턴(Strategy Pattern): 런타임에 알고리즘을 선택한다. → 완전한 분리</li>
<li>템플릿 메소드 패턴(Template Method Pattern): 추상 부분에 알고리즘의 골격을 정의하고, 구현 부분에서 이를 상속하여 각 단계를 구체화한다. → 디자인 복잡도 감소, 런타임에 구현체 변경 가능성 극대화</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/hLBD2i8m3BxlAN9KP3x0GDdqvDKtgEstMUZQqKOHn7UtJjageWSrbn3o_H5I1XQU3wt9A9RO1VP2CaaZGg3gCMfdwTm3RfNhjZDeOTdvWZRZC21cheCNZCcqeAFJYXQKSER3jYTSihxT7RUejOLAZN5YMFKkp3TMsZ9yBIJIy1yqNsEkdPKUZ8HVZRxXdxghttJJg-LUDtlEbqyo1IaOD96UbV7EyHEk" alt="uml diagram">
</li>
<li>
<p>합성(Composite)</p>
<blockquote>
<br>
컴포지트 : 객체들을 트리 구조로 구성한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>관리 편의성 : 복잡한 트리 구조에 대해 구성요소 추가/제거가 쉽다. → 관리 편의성 증가</li>
<li>단순화 : 클라이언트 코드를 단순하게 만들어주면서, 개별 객체와 복합 객체를 동일하게 다룰 수 있다. → 복잡도 감소</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>구성요소 일반화 문제 : 트리 구조의 디자인이 과도하게 일반화되어 구성요소 간의 구분이 모호해질 수 있다. → 구분성 저하</li>
<li>기능 일반화 문제 : 특정 구성요소에만 적용되는 기능을 모든 구성요소가 공유하게 되어, 설계가 불필요하게 일반화될 위험이 있다. → 기능 분리 저하</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>비지터 패턴(Visitor Pattern): 객체들에 대한 연산을 외부에서 정의하여, 컴포지트 구조의 변경없이 새 기능을 추가한다. → 기능 관리성 강화</li>
<li>스트레티지 패턴(Strategy Pattern): 개별 구성요소에 특정 행위 적용 시 컴포지트 객체의 구조적인 특징을 유지하면서 적용한다. → 유연성 증가, 특정 구성요소만 기능 추가 용이</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/pP9D3e8m48Ntd6AM48C7Q9IGiDL3DEsWa_I7j8MDyUv2bLyJmzBPlczUtxoqz86xq6gL9D0FcO2kvWAXihgn1as0HrI6ETW67G-OPWmwIt8Mk9IfOFFI5-1Gsmv_CpSCrPsKJ8aDGR856w7dEwDGt7ku8A-1TADGzxhVdtVbSYMvnoWNGow7Xi65V3XDJF6NtLIAjlb7UBiNpLi_nOOpJEnnEcdvnCSyBnPDCUWjV9J7HcsUhm1XJU1aV9AKQ6J_uLu0" alt="uml diagram">
</li>
<li>
<p>장식자(Decorator)</p>
<blockquote>
<br>
데코레이터 : 런타임에 추가 책임을 부여한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>런타임 책임 부여 : 실행 중에 객체에 추가적 책임을 추가한다. → 유연성 증가</li>
<li>확장성 : 상속없이, 기존 코드 변경없이 객체의 기능 확장 또는 제한이 가능하다. → 유연성 증가</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>추적성 문제 : 과도하게 사용 시 디버깅이 어렵다. → 추적성 저하</li>
<li>복잡도 문제 : 사용하면 할수록 복잡해진다. → 복잡도 증가</li>
<li>오버헤드 문제 : 작은 객체가 많아질 수 있다. → 메모리 효율성 저하 및 런타임 오버헤드 증가</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>스트레티지 패턴(Strategy Pattern): 행동 변화가 초점인 경우 행위를 클래스의 집합으로 캡슐화한다. → 복잡도 감소</li>
<li>팩토리 패턴(Factory Pattern) / 추상 팩토리 패턴(Abstract Factory Pattern): 객체 생성 과정 복잡도를 단순화한다. → 복잡도 감소 및 생성 오버헤드 감소</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/hLDBRi8m4Dtd5BDiGIdxI20AtNVH4nXxK5qbTcHFKAMg4clMN84zAyIPW4CmDJH9LH68nAmilpVFRpuUUXAEYYoD8k3GXj1DXKGOsoot1Wt1Lq1-ecjpT8BmuJ61cTKg0D-dJ9aAxpdBI8U4LRREyXGpFldMacBYoGb9P-qNb9QfrbtJZENlPLBX5r-4FfJyfnAxN5ffundmaz2ekhEQ2Q4KgZTYjGHU9nye6otqEeVDShUUmswxtYzMdHxuWacLeV-C6ooE6YtUqKQG2nMFy5tCj7KDEvBgLlCgV8jPdSNZGMqp4c097-2g3JQE_r3K2M5UDEIEyOyu0W00" alt="uml diagram">
</li>
<li>
<p>외관(Facade)</p>
<blockquote>
<br>
퍼사드 : 복잡한 시스템에 대해 인터페이스로 사용한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>단순화 : 복잡한 서브시스템과의 상호작용을 단순화한다. → 복잡도 감소</li>
<li>느슨한 결합 : 클라이언트와 시스템 간의 결합도를 감소시킨다. → 의존성 분리</li>
<li>사용성 : 클라이언트가 사용할 서브시스템의 기능을 더 쉽게 사용할 수 있게 한다. → 기능 사용성 증가</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>다중 기능화 문제 : 퍼사드 자체가 너무 많은 역할을 담당하게 되어 시스템의 복잡도를 숨기지만, 이를 내포할 수 있다. → 버그 가능성 증가</li>
<li>영향도 문제 : 퍼사드의 변경이 내부 서브시스템들에 영향을 미칠 수 있다. → 영향 범위 증가</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>컴포지트 패턴(Composite Pattern): 퍼사드가 단일 객체처럼 여러 객체를 관리할 수 있게 한다. → 관리성 증가</li>
<li>커맨드 패턴(Command Pattern): 퍼사드에서 여러 작업을 수행하는 경우 이러한 작업들을 캡슐화한다. → 책임 분배, 유연성 유지/증가</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/SoWkIImgAStDuU9I08BadCJYOWMtnEJ4b5I5Qh0G26Zd5wGM9PQa6cfeMYcKvMUcADWg59Sc5LSMbwJc6kf1PJKqhH6YHWXH36ECi1bZZAQX5jb5mN3BiBWAPXeURKRaQJCch0r48cbrpibCpIj1qgQR1WvCAsYW8emhBKv52WQ8Akn103LJrmuMCLOAGCt544cea6vAVdaUK0LIG45LuLDaH8mYOxXz3gbvAS2a0W00" alt="uml diagram">
</li>
<li>
<p>경량화(Flyweight)</p>
<blockquote>
<br>
플라이웨이트 : 최대한의 공유 객체를 사용한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>메모리 효율성 : 많은 수의 유사 객체 생성 시 메모리 사용을 최소화한다. → 메모리 사용량 감소</li>
<li>복잡도 : 객체를 공유한다. → 복잡도 감소</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>복잡도 문제 : 코드가 오히려 복잡해질 수도 있다. → 복잡도 증가</li>
<li>객체 상태 관리 문제 : 객체 상태 관리가 어려워질 수 있다. → 관리성 저하</li>
<li>오류 문제 : 공유 객체의 상태를 외부에서 관리하기 때문에 오류가 발생하기 쉽다. → 버그 가능성 증가</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>컴포지트 패턴(Composite Pattern): 객체의 그룹화가 필요한 경우 트리 구조로 관리할 수 있게 한다. → 관리성 증가</li>
<li>스테이트 패턴(State Pattern): 객체의 다양한 상태 및 관리 복잡 시 각 상태를 객체로 캡슐화한다. → 복잡도 감소 및 외부 상태 관리 용이</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/nLBD2e904Bxx57jKmXSG2a7m5XsY1zZMIRTiLtR7JA9tRnHJIxq5pVNxPMP2YznWUSqTXz68d5lBuhokGAOPnboWDZLxj60p_kcDsO1jUT43gnImrxaNgBrWy6bPpzc8iRTKQAIoKkoH8mHiTpo3m2525s08SE4-vb7GJSk4hLbfmVtqyAR9aLR20CBGWEn09VETVfDvK3RZ1f9_P4Uv18Mp9rouKAVmDwDMGHDcb-3tdtIibZO1jP_eIdsvqZgeDab2MWEzuGi0" alt="uml diagram">
</li>
<li>
<p>대리자(Proxy)</p>
<blockquote>
<br>
프록시 : 내부적으로 처리하는 객체(대리자/자리표시자)를 사용한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>복잡도 : 원본 객체의 생명 주기 관리나 접근 제어가 용이하다. → 복잡도 감소</li>
<li>느슨한 결합 : 클라이언트와 실제 객체 사이의 결합도를 낮춘다. → 의존성 분리</li>
<li>최적화 : 원본 객체에 대한 접근 보호 또는 원본 객체가 요구하는 리소스를 최적화하여 공급한다. → 객체 최적화</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>성능 문제 : 프록시 객체를 통해 작업을 수행한다. → 응답 시간 지연 및 성능 저하</li>
<li>복잡도 문제 : 내부에 객체를 보유한다. → 복잡도 증가</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>캐싱(Caching): 캐싱을 통해 반복된 요청의 결과를 저장하고 빠르게 응답한다. → 성능 상승</li>
<li>어댑터 패턴(Adapter Pattern): 프록시와 원본 객체 간의 인터페이스 차이를 극복시킨다. → 성능 저하 최소화, 호환성 증가</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/dP5B2W8n38RtSuei5HaFK506l83e2MeRfT9vsAIYY7Utyt0CYYxCCd_-V7aKn3fmB7sMGGfNCOQzDWZRk3kYORXr-JPc0KyHYITJ1UVQsKwuzpxZDH5iKFkdpvMDnn8hfhzQhKDzkVvkaeSNJadsLmmiG7Zce_g9NtcNg1BMj0Cfa8Z1CTJcot561P6GtiH-8o7rYQJ8iocmwF6WEHLb1LOslUO1" alt="uml diagram">
</li>
</ol>
<h2 id="%ED%96%89%EB%8F%99-%ED%8C%A8%ED%84%B4behavioral-patterns">행동 패턴(Behavioral Patterns)</h2>
<ol>
<li>
<p>행동 패턴</p>
<blockquote>
<br>
행동 패턴 : 객체의 책임/분배에 관련되는 패턴이다.<br>
<br>
<ul>
<li>협력성 : 객체가 어떻게 협력하여 작업을 수행할지를 명확하게 한다.</li>
<li>책임 : 개별 객체에 책임을 부여하여 결합도를 낮추고, 재사용성을 높인다.</li>
<li>통신 : 객체 간 통신 방식을 결정하여 코드를 명확하게 하고 유연성을 제공함으로써 더 큰 기능을 수행할 수 있도록 돕는다.</li>
<li>캡슐화 : 알고리즘 또는 상태의 변화에 따른 영향을 최소화하고 변화 부분을 캡슐화한다.</li>
</ul>
<br>
</blockquote>
</li>
<li>
<p>명령(Command)</p>
<blockquote>
<br>
커맨드 : 요청을 객체의 형태로 캡슐화하여 큐로 전송하고, 그 반대 측에서 요청을 처리한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>느슨한 결합 : 요청 측과 요청 수행 측 객체의 결합도가 낮아진다. → 의존성 분리</li>
<li>구현 난이도 : 로깅, 취소 등에 대해 구현이 쉬워진다. → 구현 난이도 감소</li>
<li>쉬운 명령 추가 : 기존 코드 변경없이 새 커맨드 추가로 새 명령 추가가 쉽다. → 확장성 증가</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>복잡도 문제 : 작은 기능에도 커맨드 클래스가 필요하여 클래스의 수가 증가할 수 있다. → 복잡도 증가</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>컴포지트 패턴(Composite Pattern): 복잡한 커맨드를 조합하여 복합 커맨드를 만들 수 있게 된다. → 복잡도 감소 및 개별적 명령 복잡도 관리성 증가</li>
<li>플라이웨이트 패턴(Flyweight Pattern): 커맨드 객체의 수를 감소시킨다. → 메모리 사용량 감소</li>
<li>뮤터블 유형 회피 : 변경 가능한 객체를 피하고, 각 커맨드가 잘 정의된 동작만을 가지도록 만든다. → 복잡도 감소 및 개별적 명령 복잡도 관리성 증가</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/VP9DRWCX38NtSmel9wgO0o2rYjHLjxq1yZWjAZyLa4cagdSlOJ0XxQIi47v-_copZqc5TBHc620VxHA5WqA2Ps-jSZDybVVBUQ0puJ7Hk9EmU3sNmFUQXqR5c7CS1ah4kTf-6hBaKjom4u6Gz491mckztIq5Zy3gIM7Itesxl-NPfcTczJta5xVuZviKWIkgPEQhMQHKtqPiuTwwg7InxD2huTIQsfYSqNbCFSNgaeTJ2JSfhZMgVEg2ZawC-0yS9tAWPwjK8kYtzoIUsh0av3AH-ofI3edPdroMyhube38cmctllp-AC7Iu56WRvBIsx65FRixVz0S0" alt="uml diagram">
</li>
<li>
<p>책임사슬(Chain of Responsibility)</p>
<blockquote>
<br>
체인 오브 리스폰시빌리티 : 요청을 처리할 수 있는 객체의 체인을 통해 요청을 보내고, 처리할 객체를 찾을 때까지 체인을 따라 요청을 전달한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>런타임 결정 : 요청을 처리할 객체를 런타임에 결정 가능하다. → 유연성 증가</li>
<li>느슨한 결합 : 요청 측과 요청 수행 측 객체의 결합도가 낮아진다. → 의존성 분리</li>
<li>책임 분산 : 여러 객체에 책임을 분산한다. → 유연성 및 확장성 증가</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>성능 문제 : 요청 처리가 체인의 마지막 체인까지 도달하는 시간이 오래 걸릴 수 있다. → 성능 저하</li>
<li>처리 불가 문제 : 요청이 전혀 처리되지 않을 위험이 있다. → 책임 회피 및 버그 가능성</li>
<li>복잡도 문제 : 체인 구성이 복잡해질 수 있다. → 복잡도 증가</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>컴포지트 패턴(Composite Pattern): 객체의 트리 구조를 통해 부분-전체의 계층을 구성한다. → 요청 분배 관리성 증가</li>
<li>커맨드 패턴(Command Pattern): 요청을 객체로 캡슐화한다. → 체인의 각 단계 요청 처리 방법에 대한 명확성 확보</li>
<li>체인의 길이와 각 핸들러의 책임을 적절히 관리한다. → 성능 저하 최소화</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/nLAzRiCW4Dxz52TdiLLX9HajjOdK9NFp10HVQqi4KkxSH8hoxY4OuwgrrB5CSFVz7R0bbexxeyuoy4iUY9rK34fB8jX9qsXqS0tDnrfGhnGIMLUFtTHxQaEXSFZP8t5PmvVjcgbDoFkHNVpMYNXuXeBRZgg4y9MqBuFSRKWxX7orHZbaZ38hm0kZQURIpoVq-agQ0Rs1u6rFw2HZKK8zULS_s7z6MVzd5DsXuM-6Og3ClLkoI24YThGnU7wRSOeUmdKVBOkND6KDCLT0ZTLybOCL6jzPGBwiAd-S26coBDlw6_CVyWu0" alt="uml diagram">
</li>
<li>
<p>해석자(Interpreter)</p>
<blockquote>
<br>
인터프리터 : 어떤 언어에 대해 그 언어의 문법에 대한 표현 방법을 정의하고, 이를 사용하여 해당 언어로 작성된 문장을 해석한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>확장성 : 문법 변경이 쉽다. → 언어의 문법 변동성 적응 용이</li>
<li>느슨한 결합 : 기존 코드 변경없이 새 표현식을 추가할 수 있다. → 의존성 분리</li>
<li>관리성 : 복잡한 문법도 나누어 작은 클래스로 관리할 수 있다. → 관리성 증가</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>복잡도 문제 : 복잡한 문법 구조인 언어인 경우 많은 수의 클래스가 필요하다. → 복잡도 증가</li>
<li>성능 문제 : 해석 과정이 비효율적일 수 있다. → 성능 저하</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>비지터 패턴(Visitor Pattern): 트리 구조나 그래프 구조를 가진 인터프리터의 요소들에 대해 새 연산을 정의할 때 사용한다.→ 인터프리터 패턴의 클래스 계층 구조 유지 및 새 기능 추가 용이</li>
<li>플라이웨이트 패턴(Flyweight Pattern): 인터프리터가 사용하는 표현식의 인스턴스를 재사용한다. → 메모리 사용량 감소</li>
<li>인터프리터 구성 요소 캐싱 또는 결과 저장/재사용을 수행시킨다. → 성능 최적화</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/hPB1QiCm38RlUGeTEue7xT6mqL5stQalu3bgPd3i82bjOUpTvpQfwuBPOPkEqkV__srhms98njut3QIotZ33DWR1ay3dfVSrZLpgqTvOX9Tt5Z9MNay38REBOIRFjRnmQI0BEydegzw3XaDqRIaw-UsGUXUCBmHTFtZiCGZ_lztRUVvhHuMvkz8Lj0Qkg-2VBh7rBcKjSsKHf1zpBKV6nQmBJr0SUxpb27Yy9YYzPrT5hliGzPmtHOCbD89yHxNn619KUKuDASG4LwPg7EwqCrl_kQXKtSDq7M6NOpKR36rQzMy0" alt="uml diagram">
</li>
<li>
<p>반복자(Iterator)</p>
<blockquote>
<br>
아이터레이터 : 컬렉션의 구현 방법에 상관없이 그 요소들을 순차적으로 접근한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>일관성 : 컬렉션 내부 구조에 상관없이 일관된 방식으로 순회한다. → 복잡도 감소, 호환성 증가</li>
<li>동시 순회 : 여러 개의 순회 연산을 동시 수행할 수 있다. → 동시성 증가</li>
<li>느슨한 결합 : 컬렉션 클래스와 순회 방식을 분리하고, 컬렉션 클래스 수정없이 새 순회 방식을 추가할 수 있다. → 의존성 분리</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>성능 문제 : 단순 컬렉션에서는 오버헤드가 될 수 있다. → 성능 저하</li>
<li>상태 관리 문제 : 아이터레이터의 상태 관리가 복잡해질 수 있다. → 복잡도 증가</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>비지터 패턴(Visitor Pattern): 컬렉션의 각 요소에 대해 복잡한 연산을 수행해야 할 때, 아이터레이터로 순회하고 비지터로 연산을 위임한다. → 역할 분담, 체계성 증가</li>
<li>컴포지트 패턴(Composite Pattern): 객체들의 그룹을 트리 구조로 구성하여 복잡한 구조를 가진 컬렉션에 대해 아이터레이터 패턴로 접근 방식을 단순화 시킨다. → 복잡도 감소</li>
<li>메멘토 패턴(Memento Pattern): 아이터레이터의 현재 상태를 저장하고 복원할 필요가 있을 때, 순회의 상태를 관리한다. → 상태 관리 복잡도 감소</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/bLAnJiCm4Dtz5JScgeB4QYceY8a5kbSCRd9DZ18R-Iuj0l7lE6djH6uOy6JvlNlltPstnChnq7T2W3_QCBgZgX2U_KMnTV0z0UFPj8fUy9Ep72GShErGcHaq0Nazl6F54_2JgZusZSD6CIvbAuV-9HXckOpcIv6gKqJmP8sdCyv2kl_ei4V3z5zrAC7WEKf62hUQyh-jO_d2UMLQXGffv6tgcLKDpdc9dINDsXev3akiZ3nEtATEQg0iWVGNYdGPOHU-f5QizadTfhn_MscpqvwpR4HVcqlsCXcnKoTqXAFPoUhQM-bZ5YhkOlnyIZ2Y0Rf4NFfVdOlQdatnCCzKma185qgwWyBffcNFllqO4k86I8Wjcjf_yry0" alt="uml diagram">
</li>
<li>
<p>중재자(Mediator)</p>
<blockquote>
<br>
미디에이터 : 객체 간의 복잡한 통신을 캡슐화한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>느슨한 결합 : 객체들이 직접 서로를 참조하지 않고, 그 통신을 중개한다. → 의존성 분리, 유지보수 및 재사용성 증가, 개별 컴포넌트 변경에 대해 독립적 관리</li>
<li>집중 : 통신 로직을 집중시킨다. → 시스템 이해도 증가</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>역할 문제 : 미디에이터 자체가 복잡해지면서, 신(GOD) 역할을 해버릴 수 있다. → 복잡도 증가</li>
<li>재사용성 문제 : 개별 컴포넌트들은 재사용성이 떨어질 수 있고, 미디에이터없이는 독립적 기능/역할 수행이 어려워질 수 있다. → 개별 컴포넌트 재사용성 저하</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>옵저버 패턴(Observer Pattern): 미디에이터가 이벤트를 발행하고 객체들은 이벤트 구독한다. → 통신 복잡도 감소</li>
<li>파사드 패턴(Facade Pattern): 미디에이터의 복잡성을 외부에 노출시키지 않고 단순화된 인터페이스를 제공한다. → 시스템 복잡도 감소</li>
<li>커맨드 패턴(Command Pattern): 미디에이터 내부에서 수행되는 각 작업을 커맨드 객체로 캡슐화한다. → 복잡도 감소</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/fP9DQiCm48NtEiNWLKBZGhCK569rNRh82HHvKgjOaf4cVvJSlHF7SHtgDe5g9PZtvdiZpIAHZhHnjH30nth2kDO6uHLBgob4-6mBf_FW0zdrOPBGbnWblAq-qD0CS8kU92mfMly-RUN7SpjJwvJW9NWJaR1lQLrJesDJ6iFa9hWcU2u_IVPUxYFr-Q0-5__EgNJ2ljymaEj2oZxkDwiC9zjaAc4RR0dFS14_TYceica6MGlFHb-d8nQ0U-B8lmTXM76RLFn9KVTGr6sAkgRy-EEGvyFH95GwtQ5K0-Lrm6pJPAssDyhpkch3UxIpL0cnuC5ubxy0" alt="uml diagram">
</li>
<li>
<p>기억(Memento)</p>
<blockquote>
<br>
메멘토 : 객체의 상태를 이전 상태로 복원한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>캡슐화 : 객체의 내부 상태를 외부에 노출하지 않고도 상태를 저장하고 복원한다. → 캡슐화 유지</li>
<li>상태 관리 : 객체의 상태 복원 기능을 제공한다. → 유연성 증가</li>
<li>간접 상태 관리 : 직접적 객체 상태 관리 대신, 쉽고 안전하게 복원 가능하다. → 안정성 증가</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>메모리 효율성 문제 : 많은 메멘토 객체가 생성될 수 있다. → 메모리 사용량 증가</li>
<li>상태 관리 문제 : 관리 대상 메멘토가 많아질수록 관리 로직이 복잡해진다. → 복잡도 증가</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>프로토타입 패턴(Prototype Pattern): 메멘토 객체를 효율적으로 복제한다. → 생성 비용 감소</li>
<li>커맨드 패턴(Command Pattern): 상태 변화를 커맨드로 저장한다. → 메멘토 생성없이 상태 복원</li>
<li>스테이트 패턴(State Pattern): 메멘토가 다루어야 할 상태를 좀 더 체계적으로 관리한다. → 체계성 증가</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/TP9D2m8X48Rl-ok6JdsmXwvBB0j1fw93_O4XXqLA1PqYYFvxhkb-97aPS1vVttcrSOoMx-fM5E3NvOREmT7ALcfaO-4LjhjLUf89AZYnbRej-iRA4P-wtZmG2LXKy31I35YRi4MlCKZWWqBpR0waIBF9nE9-hhUpHgL3wbjxUdhLUpna9B89StD_Z4_KjcY9yKgJnAARlNJiS-lA9jvQZ-938TAmW-iikhdKWfuLICq_OKGVeqURhMTGbdMeQSmAkenTG0UpFRaSamerjfuj6jB2_uqF" alt="uml diagram">
</li>
<li>
<p>관찰자(Observer)</p>
<blockquote>
<br>
옵저버 : 객체의 상태 변화를 관찰하고, 상태 변화에 따라 하나 이상의 의존 객체에게 자동으로 알린다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>느슨한 결합 : 발행자와 구독자로 나눈다. → 의존성 분리</li>
<li>모니터링 : 손쉽게 관심 대상 객체의 상태 변화를 모니터링할 수 있게 된다. → 반응력 증가</li>
<li>자동 알림 : 발행자의 상태 변화에 따라 등록된 구독자들에게 자동으로 알려서 반응한다. → 상태 일관성 증가</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>성능 문제 : 구독자가 많을 경우, 알림을 보내는데 많은 시간이 소요될 수 있다. → 성능 저하</li>
<li>강한 참조 문제 : 구독자와 발행자 간 강한 참조 발생의 위험이 있다. → 메모리 누수 가능성, 객체 간 복잡도 증가</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>미디에이터 패턴(Mediator Pattern): 복잡한 업데이트 로직을 중앙에서 관리한다. → 발행자와 구독자 간 커뮤니케이션 간소화</li>
<li>이벤트 채널(Event Channel): 이벤트 채널이나 메시지 큐를 사용한다. → 비동기적 이벤트 처리</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/dPB12i8m44Jl-Ogbfwhqu3M825u53tv1JDSQQPEItGeY_hir6gsje9XJO2QJjvCiY9NdfYg5W7OPo-XtIYEijuJ-Y1xEGRYjILFdYZ6bPdj0pH8szyr8mj6PFFWkznnTAY9OEgizCZwpJ5MNMA5b-fIVzODVYdkuDzm2j3fxOmln3zbhmeUdEw1YLdgVnjlaax8R59mv_kgqZitk56LAlxOLkJfb3L4pUcjYK1H9M1dYMRnttYchG0uztb1wvoSKjRVy3ynzscIQWCkyAVQSGJ9EXeyl8LHXa8HOeCtRJtS5" alt="uml diagram">
</li>
<li>
<p>상태(State)</p>
<blockquote>
<br>
스테이트 : 객체의 내부 상태가 변경될 때마다 행동을 변경한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>느슨한 결합 : 객체는 클래스를 바꾸는 것처럼 보이게 하고, 상태에 따른 행동을 개별 클래스로 분리한다. → 응집도 증가 및 결합도 감소</li>
<li>캡슐화 : 상태 전환 로직을 상태 객체 내부에 캡슐화한다. → 복잡한 조건문과 누락 가능성 회피</li>
<li>상태 관리 : 상태 추가 또는 제거가 더 쉬워진다. → 관리성 증가</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>복잡도 문제 : 상태가 많아질수록 관련 클래스의 수가 증가한다. → 복잡도 증가</li>
<li>메모리 효율성 문제 : 다른 패턴에 비해 많은 수의 객체가 생성된다. → 메모리 사용량 증가</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>플라이웨이트(Flyweight) 패턴: 상태 객체를 공유한다. → 메모리 최적화</li>
<li>싱글톤(Singleton) 패턴: 개별 싱글톤 상태를 통해 객체 생성을 제한한다. → 메모리 사용량 감소</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/hP4n3i8m34NtdCBgL8Goi6P01Ox02QB4q4Xf2h5R8I7kJfE0oC1OBxRylzwNvOvOHvu6BmGivG9Zl6Y3S6RD2C-yJRNjTR0UMpCkbWShE9LXes0UdSs-Lu4OhucIRY8oPj01t73pE61WMXbzN1kTz0eXAJ5LGOiVcP3pggtrcfjT4UyJ4hT_0hzHChfhptB_IQYbPjV0A6NkvJG5lIOXEWnsUTeR" alt="uml diagram">
</li>
<li>
<p>전략(Strategy)</p>
<blockquote>
<br>
스트레티지 : 일 계열의 알고리즘들을 정의하고 각 알고리즘을 캡슐화하여 이들이 서로 교체 가능하게 한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>알고리즘 분리 : 알고리즘을 사용하는 클라이언트와 알고리즘을 분리할 수 있다. → 복잡도 감소</li>
<li>알고리즘 관리 : 알고리즘 추가 및 제거, 교체가 용이하다. → 관리성 증가</li>
<li>구성 활용 : 상속 대신 구성을 사용한다. → 유연성 증가</li>
<li>추적성 : 단위 테스트가 용이하다. → 추적성 증가</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>의존성 문제 : 클라이언트 코드가 스트레티지 구현 클래스에 의존할 수도 있다. → 객체 간 결합도 증가</li>
<li>알고리즘 문제 : 알고리즘이 많아질 경우, 클래스의 수가 많아진다. → 복잡도 증가</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>팩토리 메소드(Factory Method) 패턴: 별도의 팩토리로 스트레티지 객체를 생성한다. → 클라이언트와의 결합도 감소</li>
<li>의존성 주입(Dependency Injection) 패턴: 스트레티지 객체를 클라이언트에 주입한다. → 결합도 감소 및 유연성 향상</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/hT4x3i8m30RWFQUmEe5G1jOCgC34p0cYr2IHya29Yq28krC2QJinrOi7__uaosqccQZtZi5GDX2cYrG8PqgIK3_WMGQVsaYdOx9a_Ad6Lci1jsYxadcnqfIJESCn1fMGi3fxiFxgq6EWl3X-M1WdlDDidUSVAKQSJRRwvl_ArUJ9QaDyDpdpQRDj879U-dY502CpQp5qmvFU" alt="uml diagram">
</li>
<li>
<p>양식화(Template Method)</p>
<blockquote>
<br>
템플릿 메소드 : 알고리즘의 구조를 메소드에 정의하고, 일부 단계를 서브클래스에서 구현할 수 있게 한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>공통 관심사 : 코드 중복을 줄이고, 공통의 알고리즘 코드를 재사용한다. → 복잡도 감소, 체계성 증가</li>
<li>상위 정의 : 상위 클래스에서 알고리즘의 구조를 정의한다. → 복잡도 감소</li>
<li>하위 재정의 : 하위 클래스에서 알고리즘의 일부를 재정의할 수 있다. → 유연성 증가</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>변경 범위 문제 : 기존 알고리즘에 단계 추가 또는 제거를 위해 상위 클래스 자체를 변경해야 할 수도 있습니다. → 유연성 저하</li>
<li>역할 문제 : 때로는 템플릿 메소드가 너무 많은 일을 하게 될 수도 있다. → 복잡도 증가</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>스트레티지(Strategy) 패턴: 복잡한 알고리즘을 가진 템플릿 메소드의 단계들을 별도의 클래스로 분리하여 각 단계를 전략으로 취급한다. → 유연성 증가</li>
<li>팩토리 메소드(Factory Method) 패턴: 템플릿 메소드 내에서 객체 생성을 하는 경우 팩토리 메소드로 분리하여 하위 클래스에서 하게 한다. → 역할 분담, 복잡도 감소</li>
<li>훅 메소드(Hook method)와 그 개념에 대해 잘 알고 있어야 한다.</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/SoWkIImgAStDuU9I08B4fEAIeiJa4eNadCJYOWL7ADSPpAi6Am41xTpKaepyb93Kt8ASn99K3KqhXRByp1G5MuNYajG2_poWY3MO6LAU3sGYzC6b8HfG9S2AaIHg8Mw2ECKvFo-vABKa5UAKr8gIrBmKF0uarI87e770K000" alt="uml diagram">
</li>
<li>
<p>방문자(Visitor)</p>
<blockquote>
<br>
비지터 : 각 요소에 대해 수행할 연산을 별도의 클래스로 분리하여 구성한다.<br>
<br>
</blockquote>
<ol>
<li>
<p>장점</p>
<ul>
<li>느슨한 결합 : 기존 객체 구조에서 연산 추가 또는 제거 시 기존 코드를 유지할 수 있다. → 연산 의존성 분리, 복잡도 감소</li>
<li>기능 분리 : 관련없는 기능을 분리한다. → 복잡도 감소</li>
<li>연산 관리 : 방문 객체마다 다른 연산을 수행할 수 있는 다형성을 제공한다. → 유연성 증가</li>
</ul>
</li>
<li>
<p>단점</p>
<ul>
<li>변동성 문제 : 잦은 객체 구조 변동 시 모든 비지터 수정이 필요해진다. → 복잡도 증가</li>
<li>내부 구조 노출 문제 : 패턴을 구현하기 위해 공개된 인터페이스를 제공해야한다. → 객체 지향 설계 원칙 위배</li>
</ul>
</li>
<li>
<p>단점 보완 패턴과 그 기준</p>
<ul>
<li>컴포지트(Composite) 패턴: 구조 내의 개별 요소와 복합 요소를 일관되게 처리한다. → 복잡도 감소</li>
<li>이터레이터(Iterator) 패턴: 객체 구조의 각 요소에 대한 반복 접근이 필요한 경우 각 요소를 순회 가능하게 한다. → 구현 난이도 감소</li>
</ul>
</li>
</ol>
<img src="https://www.plantuml.com/plantuml/png/SoWkIImgAStDuU9I08BCl9BKehJ4v5I5iCpYp9By8eLgi3W8Q9U1X9ppyvABKajINNDISrFpIXmrKY4CAmLq6KqhXRByp1Jy-frmwdT2rbyBSLvoJc9nCLmXr8c62fcv1H0znKF8sKQ3tjc8n01LXEoynEJar88IZJA8mwrWFY3eUvXxaNrFVUETy1jFlEaOpjRIJSalpzErWqUPbK9fSMenDiLEE1LpEQJcfG0p7G00" alt="uml diagram">
</li>
</ol>
<h1 id="%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C">참고자료</h1>
<ul>
<li>유명 사이트 - Refactoring Guru : https://refactoring.guru/design-patterns</li>
<li>유명 사이트 - SourceMaking : https://sourcemaking.com/design_patterns</li>
<li>유명 사이트 - GeeksforGeeks : https://www.geeksforgeeks.org/software-design-patterns/</li>
<li>UML 도구 : https://plantuml.com/ko/</li>
<li>웹 도구 : http://www.plantuml.com/</li>
</ul>
<!-- https://cdnjs.com/libraries/github-markdown-css -->
<!-- Base Sample : https://sindresorhus.com/github-markdown-css/?utm_source=cdnjs&utm_medium=cdnjs_link&utm_campaign=cdnjs_library -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown-dark.min.css" integrity="sha512-USRvpT7dJFA7mrRx4+esmy+2mYr8vlgmDLFpkNeVEd+D5CgQvULKPYVnDV97Ywfek+e//HdSA0NlaPe4oqkwfQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="./custom/custom.css"/>
<style>
body {
    background-color: rgb(14,17,22) !important;
    padding: 0 auto;
    margin: 0 auto;
}
.markdown-body {
    background-color: rgb(14,17,22) !important;
    box-sizing: border-box;
    min-width: 200px;
    max-width: 1280px;
    margin: 0 auto;
    padding: 45px;
}

@media (max-width: 767px) {
    .markdown-body {
        padding: 15px;
    }
}
* {
    font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";

    margin-top: 0 !important;
    margin-bottom: 16px !important;

    word-break: keep-all;
}
h1, h2, h3, h4, h5, h6, p, li {
    color: white;
}
a {
    color: #BFBFBF;
}

/* Scroll */
::-webkit-scrollbar {
    display: none;
}
* {
    -ms-overflow-style: none; /* 인터넷 익스플로러 */
    scrollbar-width: none; /* 파이어폭스 */
}

/* Image */
img.XXXS{ width:30%; height:30%; }
img.XXS{ width:40%; height:40%; }
img.XS{ width:50%; height:50%; }
img.S{ width:60%; height:60%; }
img.M{ width:70%; height:70%; }
img.L{ width:80%; height:80%; }
img.XL{ width:90%; height:90%; }
img.F{ width:100%; height:100%; }

/* blockquote */
blockquote {
    padding-top: 0em;
    padding-bottom: 0em;
    margin: auto;
    color: white !important;
    border-left: 0.25em solid orange;
    background-color: #30363d;
    margin-right: 1em !important;
}

/* code */
ol > li > pre {
    margin: 24px;
}
pre {
    width: auto;
    padding-top: 1em !important;
    padding-bottom: 1em !important;
    border: 0;
    background: #2b2b2b !important;
    text-align:left;
    /* margin: 0 !important; */
    display: block;
    margin-left: 0 !important;
    margin-right: 1em !important;
}
pre > code *,
pre > code span {
    margin: 0 !important;
}
code {
    padding-top: 2.5px !important;
    padding-bottom: 2.5px !important;
    padding-left: 5px !important;
    padding-right: 5px !important;
}
code:not(pre > code) {
    color:#e0c46c;
    font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
    line-height: 1.5em !important;
}
kbd {
    margin-top: 1em !important;
    margin-bottom: 1em !important;
    padding-top: 2.5px !important;
    padding-bottom: 2.5px !important;
    padding-left: 5px !important;
    padding-right: 5px !important;
}

/* Darcula color scheme from the JetBrains family of IDEs */
.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #2b2b2b !important;
}
.hljs {
  color: #bababa !important;
}
.hljs-strong,
.hljs-emphasis {
  color: #a8a8a2 !important;
}
.hljs-bullet,
.hljs-quote,
.hljs-link,
.hljs-number,
.hljs-regexp,
.hljs-literal {
  color: #6896ba !important;
}
.hljs-code,
.hljs-selector-class {
  color: #a6e22e !important;
}
.hljs-emphasis {
  font-style: italic;
}
.hljs-keyword,
.hljs-selector-tag,
.hljs-section,
.hljs-attribute,
.hljs-name,
.hljs-variable,
.hljs-literal {
  color: #cb7832 !important;
}
.hljs-class,
.hljs-title,
.hljs-params,
.hljs-attr {
  color: #b9b9b9 !important;
}
.hljs-string {
  color: #6a8759 !important;
}
.hljs-subst,
.hljs-type,
.hljs-built_in,
.hljs-builtin-name,
.hljs-symbol,
.hljs-selector-id,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-template-tag,
.hljs-template-variable,
.hljs-addition {
  color: #e0c46c !important;
}
.hljs-comment,
.hljs-deletion,
.hljs-meta {
  color: #7f7f7f !important;
}

/* Counter */
html {
    counter-reset: h1c;
    counter-reset: h2c;
}
h1 {
    counter-reset: h2c;
}
h1 {
    padding-bottom: 5px;
    line-height: 1.6;
    font-size: 28px;
    border-bottom: 3px solid orange !important;
    counter-increment: h1c;
}
h2 {
    padding-bottom: 5px;
    line-height: 1.6;
    font-size: 24px;
    border-bottom: 1px solid orange !important;
    counter-increment: h2c;
}
h1::before {
    margin-right: 15px;
    content: "#" counter(h1c);
    color:orange;
}
h2::before {
    margin-right: 15px;
    content: counter(h2c) ".";
    color: orange;
}
.no-h1c h1::before {
    content: "# ";
    margin: 0;
}
h1, h2, h3, h4, h5, h6 {
    margin-top: 32px !important;
    margin: 0;
    padding: 0;
    display: block;
    text-align: left !important;
}
 
/*
I.
1.
    A.
    i.
        ①
        a.
            -
*/
ol,
ol > li > ol,
ol > li > ol > li > ol,
ol > li > ol > li > ol > li > ol,
ol > li > ol > li > ol > li > ol > li > ol,
ol > li > ol > li > ol > li > ol > li > ol > li > ol,
ol > li > ol > li > ol > li > ol > li > ol > li > ol > li > ol {
    list-style-type: none !important;
}

ol {
    counter-reset: part;
}
ol > li:before {
    counter-increment: part;
    content: counter(part, upper-roman) ". ";
}
ol > li > ol {
    counter-reset: unit;
}
ol > li > ol > li:before {
    counter-increment: unit;
    content: counter(unit, decimal) ". ";
}
ol > li > ol > li > ol {
    counter-reset: section;
}
ol > li > ol > li > ol > li:before {
    counter-increment: section;
    content: counter(section, upper-alpha) ". ";
}
ol > li > ol > li > ol > li > ol {
    counter-reset: subpart;
}
ol > li > ol > li > ol > li > ol > li:before {
    counter-increment: subpart;
    content: counter(subpart, decimal) ") ";
}
ol > li > ol > li > ol > li > ol > li > ol {
    counter-reset: subunit;
}
ol > li > ol > li > ol > li > ol > li > ol > li:before {
    counter-increment: subunit;
    content: "\00a0" counter(subunit, lower-alpha) ") ";
    -webkit-border-radius: 50%;
    -moz-border-radius: 50%;
    border-radius: 50%;
}
ol > li > ol > li > ol > li > ol > li > ol > li > ol {
    counter-reset: subsection;
}
ol > li > ol > li > ol > li > ol > li > ol > li > ol > li:before {
    counter-increment: subsection;
    content: counter(subsection, lower-roman) ") ";
    border:0;
}
ol > li > ol > li > ol > li > ol > li > ol > li > ol > li > ol {
    counter-reset: subend;
}
ol > li > ol > li > ol > li > ol > li > ol > li > ol > li > ol > li:before {
    counter-increment: subend;
    content: counter(subend,"-") ". ";
}

/*
IMAGE
Fig [NO]. BLABLA
*/
figure {
    text-align:center;
    margin-top:10px;
    margin-left:0;
    margin-right:0;
    width:100%;
    counter-increment: figures;
}
figure figcaption:before {
    content: 'Fig ' counter(figures) '. ';
}

/*
●
    ○
        ■
*/
ol ul { list-style-type: disc; }
ol ul li ul { list-style-type: circle; }
ol ul li ul li ul { list-style-type: square; }

/* bug fix */
ul li::before {
    visibility: collapse;
}
li::before {
    color: orange;
    float: left;
    vertical-align: top;
    margin-right: 10px;
}
li > * {
    vertical-align: top;
    margin-top: 10px !important;
}

tr.txt-center td,
tr.txt-center th {
    text-align:center;
}
tr.pm0 td,
tr.pm0 th {
    padding:3px;
    margin:0;
}
th {
    text-align:center;
}
</style>
</body>
</html>
